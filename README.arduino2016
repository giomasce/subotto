
arduino2016 PROTOCOL
--------------------

This is a brief description of the protocol used between the Arduino
MCU and the computer server during the 24 ore match in 2016. The
implementation of the server is in arduino2016.py and the
implementation of the client is in arduino2016.ino.

The server listens for incoming TCP connections on a certain address
and port. As many client as one wants (within reasonable numbers) can
simultaneously contact the server and open a TCP session. On each
connection the server receives events from the clients and sends to
the client the current score. Events received from different clients
are treated independently, so it is necessary to get sure that every
event is handled but exactly one client. The server performs no
deduplication.

Whenever they want, the server can send the scores to the client. The
score is encoded is a couple of two unsigned 2-bytes integer numbers,
written in big-endian form (i.e., first byte is more significant). The
first two bytes encode the score of the red team, the second two bytes
encode the score of the blue team. The server is expected to send an
update of the score each time it is sensible to do so (i.e., when the
score changes) or at some predefined frequency (e.g., around once per
second). The client must be able to process the updates at any time.

Whenever they want, a client can send a one-byte code to the server,
which signals that a certain event happened. Upon receiving an event,
the server must handle it properly, perhaps writing it on a database
and/or updating its internal status of the match and scores. Then it
must immediately send the updated scores using the same protocol as
above.

The code 0 is reserved for NOOP. No real event is actually associated
to this code, but still the server has to reply with the current
score. So it can be used by the client to force the immediate
transmission of the current score, or to avoid reaching the connection
timeout.

The other codes are to be interpreted as some specific event happened
in the match and catched by the client. The current table of available
codes is here:

CODE_NOOP = 0
CODE_CELL_RED_PLAIN = 1
CODE_CELL_RED_SUPER = 2
CODE_CELL_BLUE_PLAIN = 3
CODE_CELL_BLUE_SUPER = 4
CODE_BUTTON_BLUE_GOAL = 5
CODE_BUTTON_BLUE_UNDO = 6
CODE_BUTTON_RED_GOAL = 7
CODE_BUTTON_RED_UNDO = 8

It is understood that photocells are named after the team that defends
the corresponding goal, while buttons are named after the team on
which they act. So the event code CODE_CELL_RED_PLAIN means that the
blue team scored, while the event code CODE_CELL_BUTTON_RED_GOAL means
that the red team scored (or, at least, the red score has to be
incremented).

The client is not expected to independently update and internal status
of the match given the events it receives, but just trust the scores
received from the server. If it updates an internal status, then it
must blindly trust scores received by the server each time it receives
them, even if the differ from its internal prediction (since they
could be affected by events generated by other clients or other
sources).
